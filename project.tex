\documentclass[12pt,abstracton]{scrartcl}
%packages
\usepackage{bbm}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{latexsym}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{texdraw}
\usepackage{euscript}
\usepackage{graphicx}
\usepackage{multirow}
\usepackage{mathrsfs}
\usepackage{textcomp}
\usepackage{color}
\usepackage{fancyvrb}
\usepackage{pstricks,pst-node,pst-tree}
\usepackage{subfig}
\usepackage{tikz}
\usepackage{url}
%margins
\setlength{\textwidth}{6.5in} \setlength{\evensidemargin}{0in}
\setlength{\oddsidemargin}{0in}
\setlength{\textheight}{9in}
%section start markers
\newcommand{\lem}{\paragraph*{Lemma:}}
\newcommand{\cor}{\paragraph*{Corollary:}}
\newcommand{\prb}[1]{\section*{Problem {\text{#1}:}}}
\newcommand{\sprb}[1]{\subsection*{Item {\text{#1}:}}}
%abbreviations
\newcommand{\fa}{\forall}
\newcommand{\EE}{\exists}
\newcommand{\ee}{\epsilon}
\newcommand{\dd}{\delta}
\newcommand{\rr}{\mathbb{R}}
\newcommand{\rrx}{\rr^{\times}}
\newcommand{\qq}{\mathbb{Q}}
\newcommand{\nn}{\mathbb{N}}
\newcommand{\zz}{\mathbb{Z}}
\newcommand{\cc}{\mathbb{C}}
\newcommand{\ccx}{\cc^{\times}}
\newcommand{\oo}{\mathbb{O}}
\newcommand{\hh}{\mathbb{H}}
\newcommand{\pp}{\mathbb{P}}
\newcommand{\prm}[1]{#1^{\prime}}
\newcommand{\Letf}[3]{Let \({#1}:{#2}\rightarrow{#3}\) be}
\newcommand{\pard}[2]{\frac{\partial {#1}}{\partial {#2}}}
\newcommand{\FIT}{First Isomorphism Theorem}
\newcommand{\img}{\mathrm{img}\ }
\newcommand{\eq}[1]{\begin{equation}#1\end{equation}}
\newcommand{\ceil}[1]{\left\lceil#1\right\rceil}
\newcommand{\floor}[1]{\left\lfloor#1\right\rfloor}
\newcommand{\ip}[2]{\langle{#1},{#2}\rangle}
\newcommand{\contra}{\Rightarrow\Leftarrow}
\newtheorem{thm}{Theorem}
\newtheorem{clm}{Claim}
%section end markers
\newcommand{\Qed}{\hfill$\square$\newline\newline}
\newcommand{\QED}{\hfill$\square$}
%\renewcommand*\arraystretch{1.1}
\renewcommand*{\thefootnote}{\arabic{footnote}}

\title{Identifying Patterns in Expert ML Code\footnote{Pun intended}}
\subtitle{Comp150FP Final Project\footnote{Submitted in partial fulfillment of the requirements for M.S. in computer science}}
\author{Zhe Lu}
\date{10 December 2013}

\begin{document}
\bibliographystyle{alpha}
\input{epsf.sty}
\maketitle
\begin{abstract}
The aim of this paper is two-fold: (1)~identify features common to code written in Standard ML by experts and
(2)~evaluate how well expert ML code conforms to published style guides for ML.
\end{abstract}
\section{INTRODUCTION}
There are many ways to define what an expert is.
An often cited rule attributed to Malcolm Gladwell is that one requires 10000 hours of deliberate practice
in a particular field to become an expert \cite{Gla08}. But if we want to provide novice programmers
with specifics during these 10000 hours, what should we tell them? One challenge is that experts themselves
do not necessarily know what features identify them as experts and what features are unique to them as individuals.

I attempt to shed light onto this project by employing software metrics, by trying to find measureable quantities
that provide some metric for evaluating software. Specifically,
I approach this problem by examining source code written by experts.

For samples of expert code, I turned to prominent projects where the source code is readily available:
\begin{enumerate}
\item The Standard ML of New Jersey compiler (SMLNJ),\footnote{\url{http://smlnj.cs.uchicago.edu/dist/working/110.76/compiler.tgz}} whose parser was used extensively for code analysis in this project
\item The MLKit compiler for SML\footnote{\url{http://www.itu.dk/research/mlkit/dist/mlkit-4.3.0-src.tgz}}
\item FoxNet, an implementation of the standard TCP/IP networking protocol stack in SML\footnote{\url{ftp://ftp.cs.cmu.edu/project/fox/snapshot/foxnet.tar.gz}}
\item Til, a type-directed compiler for ML\footnote{\url{http://www.cs.cornell.edu/Info/People/jgm/til.tar.Z}}
\item MLton, an open-source, whole-program, optimizing SML compiler\footnote{\url{http://sourceforge.net/projects/mlton/files/mlton/20130715/mlton-20130715.src.tgz/download}}
\end{enumerate}

The layout of this paper is as follow.
Section~\ref{sec:metric} provides a very brief background
concerning software metrics and source code analysis.
I look at how well expert code conforms to readily available
style guides in section~\ref{sec:style}.
Section~\ref{sec:syntax} discusses an analysis
of the distribution of syntactic forms. The implementation is discussed
in section~\ref{sec:impl}. Finally, I conclude and reflect in section~\ref{sec:future}.
\section{SOFTWARE METRICS AND SOURCE CODE ANALYSIS}\label{sec:metric}
\subsection{SOFTWARE METRICS}
One way to tackle the challenges and complexities of software development is to employ
\emph{software metrics}. These metrics allow developers and their managers to make
measurements about cost and effort, productivity, assessment of reliability and
quality, evaluating processes (including development and maintenance), and elements
related to project and product management.\cite{Ord08} Despite being around since
the early 1970s, there are still some significant issues with how measurements
about software are made in practice (see for example \cite{Jon94} and \cite{Bou12}).
Nevertheless, due to the high level of potential utility from prudent measurements,
a growing number of organizations have integrated software measurement programs into
their workflows.\cite{Ord08}

For my project, the whole of software metrics is too monolithic to employ on
such a small-scale project. Therefore, I aim to look at a more specific set of measurements,
mostly dealing with style. This approach has been used for C++\cite{Aye98} and C\cite{Tak11}.
\subsection{SOURCE CODE ANALYSIS}
\cite{Bin07} provides a definition:
\begin{quote}
\emph{Source code analysis} is the process of extracting
information about a program from its source code
or artifacts (e.g., from Java byte code or execution
traces) generated from the source code using automatic tools.
\emph{Source code} is any static, textual,
human readable, fully executable description of
a computer program that can be compiled automatically into an executable form.
\end{quote}

According to \cite{Bin07}, source code analysis has three components: a parser,
the internal representation, and the analysis of this representation.
Internal representations are many and varied, including abstract syntax trees,
control-flow graphs, and call graphs.

Source code analysis has a variety of applications in such areas as
automotive software engineering, debugging, fault location, software maintenance,
etc.\cite{Bin07}

I use the parser of the Standard ML of New Jersey compiler along with the accompanying
abstract syntax tree that it produces to perform our analyses. My analysis
consists of static analyses of the abstract syntax tree, looking for
syntactic constructs and patterns in usage.
\section{STYLE}\label{sec:style}
\subsection{Style Guides}\label{subsec:guide}
If we wish to examine how well expert code conforms to style, we need to decide
what good style is. A quick search of the web found a few style guides, from which
we will distill a few points of style to examine in the expert code:
\begin{enumerate}
\item CS312 SML Style Guide, from Cornell\footnote{\url{http://www.cs.cornell.edu/courses/cs312/2008sp/handouts/style.htm}}
\item SML Style Guide, from CMU\footnote{\url{http://www.cs.cmu.edu/~15150/resources/style.pdf}}
\item Syntactic Conventions, from MLton website\footnote{\url{http://mlton.org/SyntacticConventions}}
\end{enumerate}
Let's take a look at what we can discover.
\subsection{Tabs vs. Spaces}
If one wishes to start a flame war on StackOverflow, one simply needs to start
a debate over spaces and tabs. The three style guides, nevertheless, are
united on the view that tabs are taboo in SML code. To paraphrase the CMU
style guide, white space should emphasize the structure of the code.\cite{Cmu12}
Tabs, which are potentially rendered differently for
different users, cannot be used to consistently provide the desired indentation.
\begin{table}[h!]
\centering
\begin{tabular}{|c||c|c||c|}
\hline
Project & Tabs & Lines & Lines per instance \\ \hline\hline
SMLNJ & 43362 & 81124 & 1.87 \\
MLKit & 329012 & 530334 & 1.61 \\
FoxNet & 5593 & 8545 & 1.53 \\
Til & 143103 & 222317 & 1.55 \\
MLton & 0 & 168323 & -- \\ \hline
\end{tabular}
\caption{Occurrences of tab characters in expert code.}
\label{table:tab}
\end{table}

We can see from Table~\ref{table:tab} that most expert code does
not conform to the tab/spaces rule. The notable exception is
the zero occurrences of tabs in MLton, whose style guide we are using.
It's good to see that the experts at MLton stick to their own guidelines.

So while this rule seems prevalent in the style guides I've looked at,
the majority of expert ML coders do not conform to this rule.
\subsection{The 80-Column Rule}\label{subsec:80}
All three style guides recommend a line of code should not exceed 80 columns.
The 80-column rule is a UNIX convention and many text editors automatically
wrap at 80 columns. \cite{Cmu12}
\begin{table}[h!]
\centering
\begin{tabular}{|c||c|c||c|}\hline
Project & Tabs & Lines & Lines per instance \\ \hline\hline
SMLNJ & 350 & 81124 & 231.78 \\
MLKit & 18170 & 530334 & 29.187 \\
FoxNet & 31 & 8545 & 275.65 \\
Til & 1380 & 222317 & 161.10 \\
MLton & 2884 & 168323 & 58.364 \\ \hline
\end{tabular}
\caption{Violations of the 80 column rule}
\label{table:80}
\end{table}

The example code from the expert ML users I looked at clearly cannot
resist violating the 80-column rule (Table~\ref{table:80}). A quick glance
at the violations shows that most of the cases consist of exceeing the limit
by only a few characters. While most editors can be configured to insert
spaces in place of tabs, there is no active check on enforcing the 80-column
rule while coders are working. I suggest here that many of the violations
simply escaped the notice of their authors. Indeed, MLton contains
many width violations in spite of what is stated in the style guide.
\subsection{Misuse in Expressions}
\subsection{Newlines and Grouping}
\section{SYNTACTIC FORMS}\label{sec:syntax}
\subsection{Imperative Features}\label{subsec:imper}
In Prof. Norman Ramsey's class on programming languages at Tufts University, one easy way to lose points
on any assignment was the unnecessary use \emph{imperative} language features when programming in a \emph{functional} language.
\footnote{See, for example: \url{http://www.cs.tufts.edu/comp/105-2013s/homework/scheme.html}, specifically, the section titled ``Dire Warnings''}
In Standard ML, there are two main imperative constructs in terms of expressions:
(1)~the \texttt{while} expression and (2)~a list of expression separated by semicolons (similar to the \texttt{begin...end} syntax of Pascal)\cite{Ull98}.
The former has the form \texttt{while <boolean-expression> do <expression>} and always returns a value of unit type.
The return value indicates that the \texttt{while} expression's purpose is to produce the side-effects associated
with the expression in its body. The sequence of expressions evaluates only to the last in that sequence, indicating
in a similar fashion, that all expressions in the list except for the last are evaluated for side-effects.

Of course, one of the paradigms in writing functional programs is to avoid side-effects.
Such a principled approach allows us to reason better about correctness and
removes the constraints imposed by having a fixed order of execution.\cite{Hug90} Therefore,
it behooves us to examine whether such imperative features are necessary or avoidable.
\subsubsection{Expressions with \texttt{while}}
\begin{table}[h!]
\centering
\begin{tabular}{|c||c|c||c|c|c|}
\hline
Project & \multicolumn{2}{c||}{Instances of \texttt{while}} & Lines & \multicolumn{2}{c|}{Lines per instance} \\ \cline{2-3}\cline{5-6}
 & total & outside of tests &  & total & outside of tests \\ \hline\hline
SMLNJ & 0 & 0 & 81124 & -- & --\\ 
MLKit & 18 & 0 & 530334 & 29463 & --\\
FoxNet & 0 & 0 & 8545 & -- & -- \\
Til & 104 & 1 & 222317 & 2137.66 & 222317 \\
MLton & 20 & 0 & 168323 & 8416.15 & --\\ \hline
\end{tabular}
\caption{Occurrences of \texttt{while} expressions}
\label{table:while}
\end{table}
As we can see from Table~\ref{table:while}, two of the projects -- SMLNJ and FoxNet -- contain no occurrences
of \texttt{while} loops at all.

MLKit contains a few handfuls of \texttt{while} usages, but these instances
occur in regression tests for the \texttt{Word8Array} structure and not in the actual implementation of the compiler.
The 20 occurrences of \texttt{while} expressions in MLton are likewise found in code for regression testing but
also in MLton's benchmarks suite.

Of the 104 instances of a \texttt{while} expression in the Til project,
only 1 of these was found outside of a source file used for regression or benchmark testing.
This singleton appears to be used to ``touch''
structures in order to ``drag in'' other needed structures.\footnote{This analysis is roughly gleamed from limited comments in the source code.}
The body of the while loop includes modifying a mutable reference, which justifies the use of
an imperative feature. Nevertheless, it is unclear whether we might be able to rewrite the code
to avoid the use of mutable variables altogether.

Overall, we can observe that there are very few usages of \texttt{while} expressions
in expert projects (on average, one occurrence per about 2000 lines of code).
When code used for testing is excluded from the analysis, I found only one use
of a \texttt{while} expression which was used to modify mutable data.
From the analysis, expert ML programmers seemed quite principled in avoiding imperative
elements of ML. This is perhaps not surprising since they could have chosen
to implement in any language but selected a functional language in the end.
I therefore recommend that beginners avoid using \texttt{while} loops completely.
\subsubsection{Expression List}
\begin{table}[h!]
\centering
\begin{tabular}{|c||c|c||c|c|c|}
\hline
Project & Instances of expression lists & Lines & Lines per instance \\ \hline\hline
SMLNJ & 1970 & 81124 & 41.18 \\ 
MLKit & 7900 & 530334 & 67.13 \\
FoxNet & 77 & 8545 & 111.0 \\
Til & 4414 & 222317 & 50.37 \\
MLton & 1907 & 168323 & 88.27 \\ \hline
\end{tabular}
\caption{Occurrences of \texttt{while} expressions}
\label{table:explist}
\end{table}
Table~\ref{table:explist} shows how often expression lists are used in our
examples of expert ML code. We find that the number of uses is significantly
greater than that of the \texttt{while} expression. The greatest number
of occurrences, normalized by the number of lines, appears to be in the SMLNJ
compiler where we find an expression list on average once every with every
40 or so lines of code.

The expression lists are likely used for the side-effects of the non-terminal
expression in the list. Sadly, the expressions are quite complex and difficult
to aggregate into meaningful groupings programmatically. Nevertheless,
looking at the examples of expression lists in the expert code, we find that
the expression lists frequently occur in the following contexts:
\begin{itemize}
\item[$\bullet$] pretty printing
\item[$\bullet$] outputting error messages
\item[$\bullet$] other types of I/O
\item[$\bullet$] assignment of reference variables (with \texttt{:=})
\item[$\bullet$] arrays
\item[$\bullet$] with the keyword \texttt{use} or the compilation manager to bring in other modules
\end{itemize}

Haskell has the IO monad to allow users to perform I/O in a purely functional way. \cite{Jon93}
Standard ML does not, so users are left to perform their
I/O unsafely in imperative fashion.

Arrays and references are two examples that \cite{Ull98} cites as way to ``violate the functional,
side-effect-free style,'' but also noting that ``there are situations where programs cannot
be made adequately efficient unless we are allowed to change some value bindings.''

Imperative features are clearly unavoidable as evidenced in expert ML code. The experts do
limit their uses of expression lists to a few general cases, mostly dominated by I/O.
I conclude that the ML experts believe in the ``functional, side-effect-free'' style
and conform to it as much as possible. Beginners in ML are encouraged for follow their example.
\subsection{Common Library Functions}\label{subsec:imp}
\subsection{User-Defined Functions}\label{subsec:userfun}
\subsection{Program Structure}\label{subsec:struct}
\section{IMPLEMENTATION}\label{sec:impl}
\section{CONCLUSIONS AND FUTURE WORK}\label{sec:future}
\begin{thebibliography}{99}
\bibitem[Gladwell 2008]{Gla08} Gladwell, M. (2008) \emph{Outliers}. Little, Brown and Co., New York, NY.
\bibitem[Ullman 1998]{Ull98} Ullman, J.\,D. (1998) \emph{Elements of ML Programming} (ML97 Ed). Prentice Hall, Upper Saddle River, NJ.
\bibitem[Binkley 2007]{Bin07} Binkley, D., 2007. Source Code Analysis: A Road Map. In \emph{Workshop on the Future of Software Engineering (FOSE'07)}. Minneapolis, MN. 104--119. Washington, D.C.: IEEE Computer Society.
\bibitem[Vogelsang et al. 2010]{Vog10} Vogelsang, S., Fehnker, A., Huuck, R., Reif, W. (2010) Software Metrics in Static Program Analysis. In \emph{Formal Methods and Software Engineering. Proceedings 12th International Conference on Formal Engineering Methods (ICFEM'10)}. 485--500.
\bibitem[Ordonez and Hadda 2008]{Ord08} Ordonez, M.\,J. Hadda, H.\,M. (2008) The State of Metrics in Software Industry. In \emph{5th International Conference Information Technology: New Generations (ITNG'08)} Las Vegas, NV. 453--458. Washington, D.C.: IEEE Computer Society.
\bibitem[Ayerbe and Vazquez 1998]{Aye98} Ayerbe, A., Vazquez, I. (1998) Software Products Quality Improvement with a Programming Style Guide and a Measurement Process. In \emph{Proceedings 22nd Annual International Computer Software and Applications Conference (COMPSAC'98)}. 172--178.
\bibitem[Bouwers et al. 2012]{Bou12} Bouwers, E., Visser, J., van Deursen, A. (2012) Getting what you measure. \emph{Commun. ACM}, \textbf{55}, 54--59.
\bibitem[Jones 1994]{Jon94} Jones, C. (1994) Software metrics: good, bad and missing. \emph{Computers}, \textbf{27}, 98--100.
\bibitem[Takai et al. 2011]{Tak11} Takai, Y., Kobayashi, T., Agusa, K. (2011) Software Metrics Based on Coding Standards Violations. In \emph{2011 Joint Conference of the 21st Int'l Workshop on Software Measurement and 6th Int'l Conference on Software Process and Product Measurement (IWSM-MENSURA)} Nara, Japan. 273--278. Washington, D.C.: IEEE Computer Society.
\bibitem[Hughes 90]{Hug90} Hughes, J. (1990) Why Functional Programming MAtters. In D.\,A.\,Turner, ed, \emph{Research Topics in Functional Programming}. Boston, MA: Addison Wesley.
\bibitem[Peyton Jones, Wadler 1993]{Jon93} Peyton Jones, S.\,L., Wadler, P. (1993) Imperative Functional Programming. In \emph{ACM Symposium on Principles of Programming Languages (POPL'93)}. Charleston, SC. 71--84. New York, NY: ACM.
\bibitem[CMU 2012]{Cmu12} CMU Computer Science Department. (2012) SML Style Guide. Accessed on 14 Nov 2013 from \url{http://www.cs.cmu.edu/~15150/resources/style.pdf}
\end{thebibliography}
\end{document}
